# Queue Ticket

ความยาก: ★★★

โจทย์ข้อนี้เราต้องดูก่อนว่าคำตอบต้องการข้อมูลอะไรบ้าง

## ตัวแปร

คำตอบต้องการ

- เลขบัตร ซึ่งต้องการค่าที่ขึ้นตามลำดับ (เพราะโจทย์ต้องการเก็บตามลำดับเวลา หรือการจัดคิว)
เพราะฉะนั้นเราจึงควรใช้ list (หรือใช้ queue ก็ได้ ถ้ารู้จัก)

- เวลารอ ซึ่งขึ้นกับ เวลาเริ่มต้นและเวลาสุดท้าย

- เวลารอเฉลี่ย เกิดจาก เวลารอรวม หารด้วย จำนวนคนรอ ฉะนั้นจะต้องมีตัวแปรเก็บค่าและนับจำนวนที่เพิ่มขึ้นจากการสั่งอาหารหนึ่งครั้ง

- extra: โจทย์มีการเรียกคิวตามลำดับเวลาด้วย เพราะฉะนั้นต้องมีตัวแปรเพื่อบอกว่าเราสนใจคิวที่เท่าไหร่อยู่

หลังจากประกาศตัวแปรที่ต้องการครบแล้ว เราก็เริ่มการเข้าคิวได้เลย

## Algorithm

มี input อยู่ทั้งหมด 4 กรณี

- reset คือการเริ่มนับบัตรใหม่ เพราะฉะนั้นเราจะกำหนดค่านั้นให้เป็นค่าที่เราเข้ามา

- new คือการเพิ่มบัตรใหม่เข้าไปในคิว เพราะฉะนั้นเราจะเพิ่มบัตรใหม่ใน list และเพิ่มค่าของบัตรขึ้นหนึ่งเพราะเปลี่ยนเป็นบัตรใบต่อไปแล้ว

- next คือการเรียกคิวต่อไป โดยเราจะเก็บคนที่เรียกข้อมูลของคิวนั้นไว้ในตัวแปรใหม่ และจบกระบวนการโดยการเพิ่มลำดับที่เราสนใจในคิวขึ้นหนึ่ง (ไปคนต่อไป)

- order คือการรับรายการอาหารจากคนที่เรียกคิวล่าสุด โดยพิจารณาจาก ตัวแปรที่ถูกกำหนดค่าใหม่ใน กรณี next แล้วนำมาคำนวณหาเวลารอได้

- avg_qtime คือ การเรียกค่าเฉลี่ยเวลารอ โดยคำนวณจากค่าที่เพิ่มขึ้นจาก กรณี order


## Full Solution

<Spoiler />

```py
q = list()
n = int(input())
ticket, total_wait_time, next_ticket, next_start_time, it, order_count = 0, 0, "", 0, 0, 0
for k in range(n):
    c = input().split()
    if c[0] == 'reset':
        ticket = int(c[1])
    elif c[0] == 'new':
        print("ticket", ticket)
        q.append([ticket, int(c[1])])
        ticket += 1
    elif c[0] == 'next':
        print("call", q[it][0])
        next_ticket, next_start_time = q[it]
        it += 1
    elif c[0] == 'order':
        wait_time = int(c[1])-next_start_time
        total_wait_time += wait_time
        order_count += 1
        print("qtime", next_ticket, wait_time)
    elif c[0] == 'avg_qtime':
        print("avg_qtime", round(total_wait_time/order_count, 4))
```

ข้อควรรู้ : ค่าเฉลี่ย = ผลรวมของข้อมูล / จำนวนข้อมูล